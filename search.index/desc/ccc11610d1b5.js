rd_("jI/O error.00AnI/O error (socket operations).AjContains the success valueAcGet the session ID.BbNeed to acknowledge received data.AhContains the error valueCkGet the AAD (Additional Authenticated Data) - the frame \xe2\x80\xa6lGet the AAD.A`Add an extensionA`Get session age.AeGet extension by typeAmCheck if extension is presentAdNumber of extensionsAgCreate new server info.AlCreate a new client builder.CdCreate a new sync engine with the required callbacksAhCreate a new pending ackBnCreate a new ack tracker with default settingsAiCreate a new sync messageAeCreate a new receiverAmCreate a new ordered receiverBiCreate a new sender with default settingsAiCreate a new sync trackerBaCreate a new initiator handshake.BaCreate a new responder handshake.C`Create a new retention manager with no old keys.AkCreate a new replay window.CgCreate a new crypto session after handshake completion.BmCreate a new rekey state starting at epoch 0.BmCreate a new compressor with default settingsAfCreate a new extensionAmCreate an empty extension setAlCreate a new server builder.BcCreate a new session ID from bytes.AeCreate a new session.AjCreate a new nonce window.CiCreate a new connection state for an established session.AoCreate a new data frame header.AlCreate a new payload header.AhCreate a new data frame.AiCreate a new close frame.CfCreate a new migration state with the initial address.AiCreate a new frame pacer.BcCreate a new retransmit controller.CaCreate a new socket builder with default options.BoCreate a new RTT estimator with initial values.AoCreate a new timestamp tracker.CcGet the current timestamp (ms since session start).AnCurrent retransmission timeoutBgGet the current retransmission timeout.oRTT estimation.AeEncrypted data frame.CfDiff representation (must be idempotent when applied).BcNo action needed (nothing to send).mNo flags set.ChRole in the handshake (affects which key is used for \xe2\x80\xa6kSync error.oServer address.BhBind to an address and start the server.CeCreate a new NOMAD socket bound to the given address.BnBind to the given address and create a socket.CcNOMAD Protocol - Core traits, types, and constants.AbGet the data bytesnExtension dataBbApplication-specific diff encodingAoReturns the argument unchanged.0000000000000000000000000000000000000000000000000000000000000000000000000000000BhInitialize the engine with initial stateBaCalls <code>U::from(self)</code>.0000000000000000000000000000000000000000000000000000000000000000000000000000000AbGet all extensionsCeDetermine what action to take based on current state.BnReceive the next state update from the server.BhReceive data from the connected address.AeGet the current role.BbSend a state update to the server.BoSend a state update to this session\xe2\x80\x99s client.BcSend data to the connected address.AiActual decompressed size.BaGet the smoothed RTT if availableAmGet the current smoothed RTT.AkNOMAD Protocol - Sync LayerBgCreate a zero session ID (for testing).lApply error.AjGraceful connection close.AdFrame parsing error.BcUser input type (e.g., keystrokes).CdK multiplier for RTO calculation (4.0 per RFC 6298).AgRekey request/response.CaOld message (version lower than already received)AoBuild the client configuration.AoBuild the server configuration.CjClear old keys (call after retention window expires or \xe2\x80\xa6AdClear all extensionsAkTransition to closed state.AlCreate a close frame header.BcCreate an empty extension (no data)AfGet the current epoch.0BdCurrent epoch (increments on rekey).lFrame flags.BiGet a reference to the underlying socket.AeGet compression levelAhCompression level (1-22)AeMaximum allowed size.mFrame pacing.AiCurrent connection phase.CaGet compression ratio (compressed / uncompressed)AjPerform a rekey operation.A`Reset the engineAcReset tracker stateAdReset receiver state0AbReset sender stateBbReset the tracker to initial stateBeReset the window (e.g., after rekey).BoSize constants from the protocol specification.BdGet a reference to the current stateAfGet the session state.AnThe new state from the client.A`Record activity.AnSession is active and syncing.AmConnection closed gracefully.AbSession is closed.AbConnection closed.AdConfiguration error.mCrypto error.mDecode error.CgConnection failed (timeout, too many retransmits, etc).oActual version.AjThe base version received.AfActual bytes received.AgActual bytes available.AeActual size received.1C`Cancel a pending ack (e.g., on connection close)AoNOMAD Protocol - Client LibraryAmGet the server configuration.AoNOMAD Protocol - Security LayerAgDecode from wire formatAaDecode from bytesBaDecode all extensions from bufferBnDerive session keys from the handshake result.BmEncode to wire format (28-byte header + diff)oEncode to bytesAeEncode all extensionsBeThe unencrypted header (used as AAD).AaThe frame header.AoUpdate the acked state version.BfReset after successful acknowledgment.AkRecord a compression resultAkRemove an extension by typeBdRetain the current keys as old keys.BaGet the RTT variance if availableAmGet the current RTT variance.AoNOMAD Protocol - Server LibraryAcServer information.AoConvert to a u64 (zero-padded).BfUpdate RTT estimate with a new sample.BeMessage was ack-only, no state changeBbAck-only message (no state change)AcSession is closing.AnConnection closing gracefully.AoMaximum retransmission timeout.0AoMinimum retransmission timeout.0BiError encoding or decoding sync messages.AaSend a frame now.AdOperation timed out.AoState was updated with the diffAlGet the byte representation.BnConvert frame type to its byte representation.AgGet the raw byte value.CfApply exponential backoff to RTO (used after timeout).AmClean up old address entries.AjConnect to a NOMAD server.CaConnect to a remote address (for client sockets).AhOur current peer versionBlDecrypt ciphertext using XChaCha20-Poly1305.BkEncrypt plaintext using XChaCha20-Poly1305.B`Record bytes sent to an address.CfRecord that we\xe2\x80\x99re sending a frame with the given \xe2\x80\xa6B`Apply speculative input locally.BfPrelude module for convenient imports.BbProcess an already-decoded message0BaSend state to a specific session.B`Send data to a specific address.AnTime when the message was sentBgUpdate the base RTO from RTT estimator.BmGet the current smoothed RTT in milliseconds.AnGet the tracker for inspectionBaVersion that needs acknowledgmentAoThe version that was duplicatedClSize of AAD for data frames (type + flags + session_id + \xe2\x80\xa6CbFrame contains only acknowledgment, no state diff.AiNew state update receivedAdServer is shut down.BdInput data is shorter than required.CjInput buffer is too short to contain valid extension data.AcFrame is too short.BgCreate an ack-only message (empty diff)BoCreate an ACK-only frame (keepalive or pure \xe2\x80\xa6AfGet the raw key bytes.AbGet the raw bytes.AlGet the session ID as bytes.0ChCheck if we can send bytes to an unvalidated address \xe2\x80\xa6CdCompress data if it meets the minimum size thresholdAaExpected version.AmThe base version we expected.AgMinimum bytes required.0AfMinimum expected size.BdExpected payload length from header.AjExtension type identifiersAiExtension type identifierBfGenerate a new random client identity.AnGenerate a new random keypair.BaGenerate a new random session ID.AmGenerate a random session ID.CfClient identity (optional, generated if not provided).AeClient identity used.BgCheck if the connection is still alive.nCheck if emptyBoCheck if this error is fatal to the connection.C`Check if reserved bits are valid (must be zero).BcMinimum size to attempt compressionAkIncrement epoch (on rekey).AkGet the opposite direction.AjThe stale version receivedBgGet the receive key for the given role.AjBytes needed for encoding.BdGet the send key for the given role.BgUpdate the SRTT from the RTT estimator.B`Gracefully shut down the server.BeSerialize header to bytes (16 bytes).AnSerialize to bytes (10 bytes).AoCreate with custom RTO settingsAfConnected and syncing.ChA complete data frame ready for encryption/transmission.BhFailed to apply the diff to local state.CbDirection of communication for nonce construction.BmDuplicate message (already have this version)BmDuplicate message (already seen this version)BhExtension TLV (Type-Length-Value) formatBjFrame type identifiers from 0-PROTOCOL.md.AiBLAKE2s hash output size.AbInitiator (client)AmKeepalive to prevent timeout.AdMaximum epoch value.AbResponder (server)CeSession ID - 48-bit random identifier for session \xe2\x80\xa6AmSession identifier (6 bytes).AlState synchronization error.AiErrors in the sync layer.AlErrors from the sync engine.CbCore trait for any state that can be synchronized.C`Wait until the specified instant before sending.AjBytes available in buffer.AeSet the bind address.AcAddress to bind to.B`Broadcast state to all sessions.CdCheck if we can perform another rekey (epoch limit).BcCreate diff from old_state to self.BoHighest state version acknowledged (encrypted).AmParse frame type from a byte.AmCreate flags from a raw byte.AmGet time since last activity.AhConsume and get the dataAkCheck if session is active.BcCheck if the connection has failed.BjCheck if we\xe2\x80\x99ve exceeded max retransmits.C`Check if a nonce is a replay (without updating).A`Migration state.AoCheck if we need to send an ack000CeNegotiate extensions between client and server offersBiGet the plaintext that will be encrypted.0BjReconcile with authoritative server state.DdGet the received data after a successful <code>try_recv_from</code>.BoReceive data and return the sender\xe2\x80\x99s address.AeSet compression levelAfSet the session state.BlGet a mutable reference to the current stateCbSender\xe2\x80\x99s current time in ms since session start.B`NOMAD Protocol - Transport LayeroTotal wire size00AfAcknowledgment trackerBkErrors that can occur when applying a diff.AjFailed to bind to address.BgA close frame for graceful termination.AcData was compressedAlCompressor for sync payloadsAfHandshake in progress.BbFailed to decode the diff payload.BkErrors that can occur during frame parsing.AlFrame flags for data frames.CbFrame pacer that controls when frames can be sent.AgTop-level NOMAD errors.BhPrediction extension (terminal-specific)BlTracks pending acknowledgments for a messageCiTracks the current key epoch and when rekeying is needed.BcRetransmitting unacknowledged data.BhScrollback extension (terminal-specific)BgAlpha for SRTT smoothing (0.125 = 1/8).BbReason why a frame should be sent.BbServer information for connection.BbA session key for AEAD operations.CcSync engine for bidirectional state synchronizationC`Sender state for managing outbound sync messagesB`Apply diff to produce new state.AgCancel all pending acksAjCreate an ack-only messageoDecompress dataBfGracefully disconnect from the server.AnDisconnect a specific session.AkNOMAD Protocol - ExtensionsAeRequested extensions.AfNegotiated extensions.AjGet negotiated extensions.BeFrame type (should be Data or Close).BdCreate a new session key from bytes.BlCreate a keypair from existing key material.AfCreate from raw bytes.AoCreate a session ID from bytes.AhParse header from bytes.AaParse from bytes.BmGet the local address the server is bound to.AfGet the local address.CcMark that we\xe2\x80\x99ve sent an ack for the given versionAmMark that we\xe2\x80\x99ve sent an ackBfRecord bytes received from an address.BhProcess a received frame\xe2\x80\x99s timestamps.AcGet the public key.AmServer\xe2\x80\x99s static public key.1BnGet the receive counter for the current epoch.BjMark as retransmitted with updated timeoutAgRetransmission control.BkGet the send counter for the current epoch.CbOutbound nonce counter (monotonically increasing).AnSession ID assigned by server.AcGet the session ID.0kSession ID.00BbSession identifier from handshake.AcSession identifier.BfGet a clone of the Arc-wrapped socket.BgTimestamp tracking for RTT measurement.CfCreate a timestamp tracker with a specific start time.AlCompression extension (zstd)BjErrors that can occur in the NOMAD client.AfInternal client state.AkErrors in the crypto layer.BkErrors that can occur when decoding a diff.BmConnection established, data transfer active.AfHandshake in progress.0AoInitial retransmission timeout.CgInitial retransmission timeout before first RTT sample.BjCompressed data is malformed or corrupted.BgExtension data is malformed or invalid.AcInvalid frame type.AhA NOMAD protocol client.AhA NOMAD protocol server.BcAsync UDP socket wrapper for NOMAD.CmNonce replay detected. Per spec: silently drop to prevent \xe2\x80\xa6CiNonce too old (outside anti-replay window). Per spec: \xe2\x80\xa6BdAnti-replay window using a bitfield.AlAction the pacer recommends.CfOptional trait for states that support client-side \xe2\x80\xa6BgBeta for RTTVAR smoothing (0.25 = 1/4).BjErrors that can occur in the NOMAD server.AfEvent from the server.BnSession keys derived from the Noise handshake.BoState has changed and needs to be synchronized.BoHandle for sending state updates to the server.BnSync message format (inside encrypted payload)CaSync tracker state (each endpoint maintains this)AdWindow size in bits.oGet bytes savedAgGet the client address.AnEnable or disable compression.BgCreate compression extension with level1BfGet current RTO based on RTT estimatesBbDeserialize diff from wire format.BeSerialize diff for wire transmission.CbEncode into existing buffer, returns bytes writtenBiEncode into buffer, returns bytes writtenCbCreate a NOMAD socket from an existing UDP socket.BlCreate a socket from an existing UDP socket.BoCreate a connection state in handshaking phase.BjCheck if there are pending acknowledgmentsBdCheck if there\xe2\x80\x99s a pending messageBdCheck if this is an ack-only messageAnCheck if ACK_ONLY flag is set.BfGet a copy of the current local state.AeMark as fully closed.oMark as failed.BgParse a nonce back into its components.AdGet the private key.0AoSet the server\xe2\x80\x99s private key.BiServer\xe2\x80\x99s static private key (32 bytes).BbProcess an incoming acknowledgmentBfProcess a raw message from wire formatBbRecord a received message counter.AmRecord that we sent a messageAgGet the server address.AgSet the server address.AmServer address to connect to.AkCheck if we should send nowBfCreate a compressor with custom configAeClient configuration.AgClient is disconnected.nNot connected.AmExtension set for negotiationBbInvalid flags (reserved bits set).BfSync message encoding/decoding errors.CeRequested extension type is not supported by this \xe2\x80\xa6AkAnti-replay sliding window.BdRTT estimator implementing RFC 6298.AeServer configuration.nSession error.nSession state.ChDecompressed size exceeds safety limit (DoS protection).AnClient state has been updated.BcReceiver for incoming sync messagesCiData was not compressed (too small or compression not \xe2\x80\xa6AiBase version for the diffChBump local state version (call when local state changes)AmGet the current client state.AlGenerate an ack-only messageBdCheck if a version has been receivedBaCheck if the client is connected.BaCheck if an address is validated.CcCheck if keys are expired (session must terminate).CkCheck if the current keys are expired (hard limit reached).BeMark that the local state has changedBnSet the maximum number of concurrent sessions.BfMaximum number of concurrent sessions.AdGet peer\xe2\x80\x99s versionBfGet highest version received from peerCaProcess the handshake response (&lt;- e, ee, se).D`Process the initiator\xe2\x80\x99s handshake message (-&gt; e, es, s, \xe2\x80\xa6AmGet the current server state.CfCheck if old keys should be cleared due to expired \xe2\x80\xa6BdCheck if we should initiate a rekey.CiCheck if we should initiate a rekey (soft limit reached).BfGet a sender handle for state updates.BeThe sync message (will be encrypted).CeForce-take the pending message (bypass timing checks)AgUpdate the local state.BnUpdate local state and bump version atomicallyBaPoly1305 authentication tag size.BhAEAD authentication tag size (Poly1305).CcA complete crypto session for secure communication.ChConsider connection dead after this long without frames.CiDead interval - consider connection dead if no frames \xe2\x80\xa6CbFrame contains only acknowledgment, no state diff.CkFrame too small to be valid. Per spec: silently drop to \xe2\x80\xa6AoExtension data follows payload.BnHandshake initiation (Noise_IK first message).BmHandshake response (Noise_IK second message).AdInvalid diff format.BgMessage format is invalid or corrupted.BjPayload header (inside encrypted portion).BmResult of processing an incoming sync messageBbResult of receiving a sync messageCcUnique type identifier (e.g., \xe2\x80\x9cnomad.echo.v1\xe2\x80\x9d).AcPer-client session.CfHandle for sending state updates to a specific client.CcHandle for receiving state updates from the server.BoA static X25519 keypair for long-term identity.AgUnexpected end of data.AnVersion acknowledged by sender0AjAdvance to the next epoch.C`Clear pending state (e.g., after receiving ACK).CfClear the pending timestamp (e.g., on retransmission).BdCompress data in-place into a bufferClConstruct AAD (Additional Authenticated Data) for a data \xe2\x80\xa6AiDecrypt a received frame.AlEncrypt a frame for sending.BcCheck if HAS_EXTENSION flag is set.B`Get highest acknowledged versionBhKey for initiator \xe2\x86\x92 responder messagesAlCheck if data was compressedCcCheck if diff is empty (optimization for ack-only).0BmWhen we last received an authenticated frame.ChNonce counter (per-direction, monotonically increasing).CmNotify the pacer that we received a frame and should send \xe2\x80\xa6BgNotify the pacer that a frame was sent.BcRecord that we\xe2\x80\x99re retransmitting.CkParse a decrypted payload to extract the payload header \xe2\x80\xa6BeGet number of pending acknowledgmentsAkQueue a message for sendingCaRegister a sent message that needs acknowledgmentCfReset RTO to initial value (e.g., after successful \xe2\x80\xa6BhKey for responder \xe2\x86\x92 initiator messagesBbGet the number of active sessions.CdNumber of payloads skipped (too small or no benefit)AlState type ID for handshake.BnTake the pending message if we should send nowBeTry to receive data without blocking.AbSet ACK_ONLY flag.CjGenerate the first handshake message (-&gt; e, es, s, ss).CbGenerate the handshake response (&lt;- e, ee, se).AhErrors during bootstrap.C`Output buffer is too small to hold encoded data.CeOutput buffer is too small to hold encoded extension.BhClient identity containing the key pair.AmResult of compression attemptBoExtension type: Prediction (terminal-specific).BoExtension type: Scrollback (terminal-specific).AhMaximum frame rate (Hz).BnMinimum frame size (header + tag, no payload).AhMigration state tracker.CeOperation requires initialized state but none exists.A`Replay detected.AgTransport layer errors.CjUnknown session ID. Per spec: silently drop to prevent \xe2\x80\xa6BcVersion this diff was computed fromAfCancel pending messageCkCheck if a nonce is valid (not replayed) and mark it as \xe2\x80\xa6BmCreate a sync message with current state infoBlThe handshake hash (used for key derivation)BhThe handshake hash (stored for rekeying)AkIncrement the send counter.BbCheck if the engine is initializedCmCheck if the estimator has been initialized with at least \xe2\x80\xa6ChCheck if this error should result in silent drop (no \xe2\x80\xa6CaCalculate maximum frame size considering headers.nNOMAD ProtocolBgThe payload header (will be encrypted).BhLength of the sync message that follows.AfThe sender\xe2\x80\x99s version0BkGet a sender handle for a specific session.AjSet negotiated extensions.BgCheck if we should send at a given timeCgGet the timestamp echo value (peer\xe2\x80\x99s last timestamp).CeMost recent timestamp received from peer (0 if none).AgSet HAS_EXTENSION flag.BeCreate a sender with custom intervalsAeXChaCha20 nonce size.AhBootstrap configuration.BaResult of a successful bootstrap.AkA new client has connected.AkConnection lifecycle state.CeFull connection state as specified in 2-TRANSPORT.md.CmDefault maximum retransmission timeout (60 seconds). Caps \xe2\x80\xa6ClDefault minimum retransmission timeout (100ms). Prevents \xe2\x80\xa6CeData frame header (unencrypted portion, used as AAD).BcExtension type: Compression (zstd).BiEpoch exhausted - session must terminate.BdData frame (encrypted sync message).AaHandshake failed.0AoResult of a completed handshakeAaInvalid encoding.CaMaximum retransmission attempts before giving up.BeMaximum retransmits before giving up.CiManages old keys during the transition period after a \xe2\x80\xa6CgReceiver with history for out-of-order message handlingAgX25519 public key size.AiSession ID size (48-bit).0BgSession ID (48-bit, as per NOMAD spec).AjState corruption detected.BeResult type for transport operations.AfDiff version mismatch.CdDiff was based on a different version than expected.CcHighest version received from peer (acknowledgment)AiAdd compression extensionAkSet the connection timeout.AcConnection timeout.BmConstruct a 24-byte XChaCha20-Poly1305 nonce.BbGet the current validated address.AiGet current local versionAoGet current local state versionBoGet versions that have exceeded max retransmitsBdParse server public key from base64.AoCheck if compression is enabledAoCheck if synchronized with peerBgCheck if the state is in sync with peerCgMark that an ack is needed (triggers delayed ack timer)BdCheck if we should send a keepalive.CiGet the next nonce for sending and increment the counter.BnNotify the pacer that local state has changed.B`Get reference to pending messageB`Process an incoming sync messageCbRemote peer address (may change during migration).AhSet the session timeout.AlSession timeout for cleanup.B`Get time until next allowed sendBcErrors from compression operations.BeStatistics for compression operationsAeConnection is closed.AlFailed to connect to server.CbAEAD decryption failed (invalid tag or corrupted).AgAEAD encryption failed.BcClose frame (graceful termination).lRekey frame.AbInvalid handshake.AcInvalid key format.AjInvalid server public key.BbErrors from extension negotiation.AhX25519 private key size.AhProtocol version (v1.0).AoInitiate rekey after this time.C`Size of the session key (32 bytes for XChaCha20)CiTimestamp tracker for RTT measurement via timestamp echo.CcCheck if a nonce is a replay and update the window.CbCheck if a received nonce is valid (not replayed).BhClear old keys if retention has expired.AmNumber of payloads compressedBnDecrypt ciphertext in-place, removing the tag.BnEncrypt plaintext in-place, appending the tag.BmCreate identity from an existing private key.BgGenerate a sync message to send to peerBgCheck if there\xe2\x80\x99s unacknowledged data.BfGet highest version received from peer0AmGet the maximum payload size.AmSet the maximum payload size.BaCheck if retransmission is neededBiGet pending acks that need retransmissionCgFrame pacing constants from the protocol specification.B`Process an incoming sync messageAlSet the receive buffer size.AiNumber of retransmissionsBaGet the current retransmit count.BcVersion of sender\xe2\x80\x99s current stateBgGet mutable access to the server state.CaTake the pending message if ready at a given timeCeRTT timing constants from the protocol specification.AmTotal bytes after compressionCnValidate an address after receiving an authenticated frame \xe2\x80\xa6AiCompression configurationAhZstd compression failed.AiConnection has timed out.CaNonce counter exhausted - session must terminate.CjCounter exhaustion - nonce counter overflow. This is a \xe2\x80\xa6AmHandshake backoff multiplier.AlHandshake timeout (initial).CeHard cap on frame rate (50 Hz = 20ms between frames).BdMinimum size to attempt compression.BkMinimum payload size to attempt compressionBlKeep old keys for late packets during rekey.BlHard limit, reject old keys after this time.AcSession terminated.AnGet the client\xe2\x80\x99s public key.AfClient\xe2\x80\x99s public key.ChGet compression level if this is a compression extensionB`Get compression level if enabledBfDerive new session keys after a rekey.CjGet the base state number that should be used for diff \xe2\x80\xa6C`Check if this error is a security-related error.AeGet last sent versionCkGet the old initiator key if still within retention window.CkGet the old responder key if still within retention window.AiPerform client bootstrap.AkInbound anti-replay window.AnSet the server\xe2\x80\x99s public key.BhServer\xe2\x80\x99s static public key (32 bytes).BbCheck if we should retransmit now.BaAnti-amplification limit reached.AjA client has disconnected.AoExtension data follows payload.CcHandshake state machine for the initiator (client).BeSend keepalive if idle for this long.CdKeepalive interval - send keepalive if no data sent.AoNonce counter size (64-bit LE).C`Builder for creating a <code>NomadClient</code>.C`Builder for creating a <code>NomadServer</code>.CgBuilder for creating NOMAD sockets with custom options.BcMinimum replay window size in bits.AnRetransmit backoff multiplier.CcHandshake state machine for the responder (server).AdUnsupported version.AoSet the client\xe2\x80\x99s private key.CmClient\xe2\x80\x99s static private key (optional, generated if not \xe2\x80\xa6CaComplete handshake and transition to established.ChDecode from wire format, returning message and bytes \xe2\x80\xa6CiDecode from bytes, returning extension and bytes consumedAmEnable compression extension.0CbCheck if the connection should be considered dead.BhGet last version we acknowledged to peerBaGet highest version acked by peerAoMark a version as retransmittedClParse a received frame to determine its type and extract \xe2\x80\xa6C`Get time until next allowed send at a given timeAnTotal bytes before compressionBkUpdate the client address (for IP roaming).CeCollection interval for batching rapid state changes.CgWait after state change before sending (batch rapid \xe2\x80\xa6CbDefault initial retransmission timeout (1 second).CeRecommended maximum payload size for mobile networks.BaMaximum delay for ack-only frame.BhMaximum time to delay an ack-only frame.AjZstd decompression failed.AfKey derivation failed.AoFailed to generate client keys.CgMinimum data frame size (header + empty payload + tag).BkNonce direction: Initiator -&gt; Responder.BkNonce direction: Responder -&gt; Initiator.C`Payload header size (timestamp + echo + length).ChHighest state version the peer has acknowledged from us.B`Check if compression is enabled.B`Check if we have updates to sendBhCheck if we have pending updates to sendBcHighest state version we\xe2\x80\x99ve sent.BnUpdate the server state and increment version.CmInvalid AEAD tag - frame authentication failed. Per spec: \xe2\x80\xa6AnInitiator \xe2\x86\x92 Responder (0x00)AgMigration rate limited.BdSoft limit on messages before rekey.AnResponder \xe2\x86\x92 Initiator (0x01)AjRetransmission controller.AmGet the client state version.CeHighest state version we\xe2\x80\x99ve acknowledged from peer.AmGet the server state version.CfSet the maximum payload size (for MTU considerations).BcCreate a tracker with initial stateAmHeader size for extension TLVAjMaximum handshake retries.CiMinimum frame interval (ms) - will use max(SRTT/2, this).AhPayload length mismatch.C`Hard limit on messages - MUST terminate session.BhDecompress data with explicit size limitBnMaximum decompressed size (for DoS protection)BcTime until retransmission is neededBlGet time until next retransmission is neededBjGet time until next retransmit is allowed.CkData frame header size (type + flags + session_id + nonce).0BlMinimum RTT granularity for RTO calculation.BlToo many retransmissions, connection failed.CdUpdate state after receiving an authenticated frame.CkDefault maximum number of retransmission attempts (10). \xe2\x80\xa6AlMinimum handshake init size.B`Minimum handshake response size.BlRecommended max payload for mobile networks.BmCheck if we\xe2\x80\x99re within the retention window.AlDefault receive buffer size.CmMinimum time between frames (lower bound). Actual minimum \xe2\x80\xa6BiSync message header size (3 x u64 + u32).BiHeader size in bytes (3 x u64 + u32 = 28)AoDefault zstd compression level.CnDefault zstd compression level (1-22, higher = smaller but \xe2\x80\xa6BnHandshake initiation (Noise_IK first message).BmHandshake response (Noise_IK second message).ChDefault exponential backoff multiplier for RTO (2x). \xe2\x80\xa6ChDefault collection interval for batching rapid state \xe2\x80\xa6AkDefault delayed ack timeoutBkUpdate the client state version (from ack).")