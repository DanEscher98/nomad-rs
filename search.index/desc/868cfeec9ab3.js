rd_("jI/O error.00AnI/O error (socket operations).111011101110AjContains the success value000AcGet the session ID.000AmAll priority levels supported000BbNeed to acknowledge received data.000AhContains the error value000CgCan be delayed if bandwidth is constrained Use for: \xe2\x80\xa6000CkGet the AAD (Additional Authenticated Data) - the frame \xe2\x80\xa6lGet the AAD.101010AkGet the AAD (frame header).A`Add an extensionB`Add support for a priority level101010A`Get session age.000BgCreate config supporting all priorities000AmGet counter for a participantAeGet extension by type101010AmCheck if extension is present000AnNumber of updates in the batchAaNumber of entriesAdNumber of extensions210210210AgCreate new server info.AlCreate a new client builder.CdCreate a new sync engine with the required callbacksAhCreate a new pending ackBnCreate a new ack tracker with default settingsAiCreate a new sync messageAeCreate a new receiverAmCreate a new ordered receiverBiCreate a new sender with default settingsAiCreate a new sync trackerBaCreate a new initiator handshake.BaCreate a new responder handshake.C`Create a new retention manager with no old keys.AkCreate a new replay window.CgCreate a new crypto session after handshake completion.BmCreate a new rekey state starting at epoch 0.AhCreate a new empty batchAhCreate a full checkpointBmCreate a new compressor with default settingsAiCreate empty vector clockAeCreate empty metadataAfCreate a new extensionAmCreate an empty extension setBhCreate new subscription state with limitAlCreate a new server builder.BcCreate a new session ID from bytes.AeCreate a new session.AjCreate a new nonce window.CiCreate a new connection state for an established session.AoCreate a new data frame header.AlCreate a new payload header.AhCreate a new data frame.AiCreate a new close frame.CfCreate a new migration state with the initial address.AiCreate a new frame pacer.BcCreate a new retransmit controller.CaCreate a new socket builder with default options.BoCreate a new RTT estimator with initial values.AoCreate a new timestamp tracker.AgCreate new server info.AlCreate a new client builder.CdCreate a new sync engine with the required callbacksAhCreate a new pending ackBnCreate a new ack tracker with default settingsAiCreate a new sync messageAeCreate a new receiverAmCreate a new ordered receiverBiCreate a new sender with default settingsAiCreate a new sync trackerBaCreate a new initiator handshake.BaCreate a new responder handshake.C`Create a new retention manager with no old keys.AkCreate a new replay window.CgCreate a new crypto session after handshake completion.BmCreate a new rekey state starting at epoch 0.AhCreate a new empty batchAhCreate a full checkpointBmCreate a new compressor with default settingsAiCreate empty vector clockAeCreate empty metadataAfCreate a new extensionAmCreate an empty extension setBhCreate new subscription state with limitAlCreate a new server builder.BcCreate a new session ID from bytes.AeCreate a new session.AjCreate a new nonce window.CiCreate a new connection state for an established session.AoCreate a new data frame header.AlCreate a new payload header.AhCreate a new data frame.AiCreate a new close frame.CfCreate a new migration state with the initial address.AiCreate a new frame pacer.BcCreate a new retransmit controller.CaCreate a new socket builder with default options.BoCreate a new RTT estimator with initial values.AoCreate a new timestamp tracker.AgCreate new server info.AlCreate a new client builder.CdCreate a new sync engine with the required callbacksAhCreate a new pending ackBnCreate a new ack tracker with default settingsAiCreate a new sync messageAeCreate a new receiverAmCreate a new ordered receiverBiCreate a new sender with default settingsAiCreate a new sync trackerBaCreate a new initiator handshake.BaCreate a new responder handshake.C`Create a new retention manager with no old keys.AkCreate a new replay window.CgCreate a new crypto session after handshake completion.BmCreate a new rekey state starting at epoch 0.AhCreate a new empty batchAhCreate a full checkpointBmCreate a new compressor with default settingsAiCreate empty vector clockAeCreate empty metadataAfCreate a new extensionAmCreate an empty extension setBhCreate new subscription state with limitAlCreate a new server builder.BcCreate a new session ID from bytes.AeCreate a new session.AjCreate a new nonce window.CiCreate a new connection state for an established session.AoCreate a new data frame header.AlCreate a new payload header.AhCreate a new data frame.AiCreate a new close frame.CfCreate a new migration state with the initial address.AiCreate a new frame pacer.BcCreate a new retransmit controller.CaCreate a new socket builder with default options.BoCreate a new RTT estimator with initial values.AoCreate a new timestamp tracker.AgCreate new server info.AlCreate a new client builder.CdCreate a new sync engine with the required callbacksAhCreate a new pending ackBnCreate a new ack tracker with default settingsAiCreate a new sync messageAeCreate a new receiverAmCreate a new ordered receiverBiCreate a new sender with default settingsAiCreate a new sync trackerBaCreate a new initiator handshake.BaCreate a new responder handshake.C`Create a new retention manager with no old keys.AkCreate a new replay window.CgCreate a new crypto session after handshake completion.BmCreate a new rekey state starting at epoch 0.AhCreate a new empty batchAhCreate a full checkpointBmCreate a new compressor with default settingsAiCreate empty vector clockAeCreate empty metadataAfCreate a new extensionAmCreate an empty extension setBhCreate new subscription state with limitAlCreate a new server builder.BcCreate a new session ID from bytes.AeCreate a new session.AjCreate a new nonce window.CiCreate a new connection state for an established session.AoCreate a new data frame header.AlCreate a new payload header.AhCreate a new data frame.AiCreate a new close frame.AiCreate a new rekey frame.CfCreate a new migration state with the initial address.AiCreate a new frame pacer.BcCreate a new retransmit controller.CaCreate a new socket builder with default options.BoCreate a new RTT estimator with initial values.AoCreate a new timestamp tracker.CcGet the current timestamp (ms since session start).000AnCurrent retransmission timeoutBgGet the current retransmission timeout.101010oRTT estimation.000AmSet counter for a participant000AeEncrypted data frame.000CfDiff representation (must be idempotent when applied).000CkImportant updates that should be delivered promptly Use \xe2\x80\xa6000BcNo action needed (nothing to send).000mNo flags set.000ChRole in the handshake (affects which key is used for \xe2\x80\xa6000kSync error.000oServer address.000BhBind to an address and start the server.CeCreate a new NOMAD socket bound to the given address.BnBind to the given address and create a socket.210210210CcNOMAD Protocol - Core traits, types, and constants.000AbGet the data bytesnExtension data101010BbApplication-specific diff encoding000AoReturns the argument unchanged.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000AoCreate config with all featuresAoCreate a full checkpoint header1BgCreate config with all features enabled212021202120BhInitialize the engine with initial state000BaCalls <code>U::from(self)</code>.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000AdIterate over updatesAdIterate over entriesAbGet all extensions210210210CeDetermine what action to take based on current state.000BnReceive the next state update from the server.BhReceive data from the connected address.101010AeGet the current role.000BbSend a state update to the server.BoSend a state update to this session\xe2\x80\x99s client.BcSend data to the connected address.210210210AiActual decompressed size.000BaGet the smoothed RTT if availableAmGet the current smoothed RTT.101010AkNOMAD Protocol - Sync Layer000BgCreate a zero session ID (for testing).000lApply error.000BiA batch of updates ready for transmission000AjGraceful connection close.000AdFrame parsing error.000BcUser input type (e.g., keystrokes).000CdK multiplier for RTO calculation (4.0 per RFC 6298).000AgRekey request/response.000CaOld message (version lower than already received)000AkApply a subscription change000AoBuild the client configuration.AoBuild the server configuration.101010CjClear old keys (call after retention window expires or \xe2\x80\xa6oClear the batchAdClear all extensions210210210AkTransition to closed state.AlCreate a close frame header.101010BaGet count of active subscriptions000BcCreate an empty extension (no data)000AfGet the current epoch.0BdCurrent epoch (increments on rekey).110110110mFeature flagskFrame flags111lFrame flags.212220212220212220BiGet a reference to the underlying socket.000AeGet compression levelAhCompression level (1-22)101010AeMaximum allowed size.000ChMerge with another vector clock (take max of each entry)000mFrame pacing.000AiCurrent connection phase.000CaGet compression ratio (compressed / uncompressed)000AjPerform a rekey operation.00CiPerform a rekey operation with the given ephemeral DH \xe2\x80\xa6A`Reset the engineAcReset tracker stateAdReset receiver state0AbReset sender stateBbReset the tracker to initial stateBeReset the window (e.g., after rekey).543321054332105433210BoSize constants from the protocol specification.000BdGet a reference to the current stateAfGet the session state.AnThe new state from the client.210210210A`Record activity.000AnSession is active and syncing.000AkCustom application metadataAfCustom data is present101010AmConnection closed gracefully.AbSession is closed.AbConnection closed.210210210AdConfiguration error.000mCrypto error.000mDecode error.000CgConnection failed (timeout, too many retransmits, etc).000BfGlobal rate hint affecting all updates000AnRequest latest full checkpoint000AkNested/hierarchical regions000CmStandard priority for most updates Use for: regular state \xe2\x80\xa6000AiRegion-specific rate hint000AhFrame includes signature000oActual version.AjThe base version received.AfActual bytes received.AgActual bytes available.AeActual size received.1432101432101432101C`Cancel a pending ack (e.g., on connection close)000AoNOMAD Protocol - Client Library000AmGet the server configuration.000AoNOMAD Protocol - Security Layer000AgCustom application data000AgDecode from wire formatAmDecode batch from wire formatAhDecode header from bytesAaDecode from bytes0000BaDecode all extensions from buffer11432111110114321111101143211111011BnDerive session keys from the handshake result.0ClDerive session keys from the handshake result and static \xe2\x80\xa60BmEncode to wire format (28-byte header + diff)AkEncode batch to wire formatAfEncode header to bytesoEncode to bytes0000AeEncode all extensions11432111110114321111101143211111011AiCreate a global rate hint000AaCheckpoint headerBeThe unencrypted header (used as AAD).AaThe frame header.210210210B`The frame header (type = Rekey).AoUpdate the acked state version.BfReset after successful acknowledgment.101010AkRecord a compression result000BbCreate a region-specific rate hint000AkRemove an extension by typeBcRemove support for a priority level101010BdRetain the current keys as old keys.000BaGet the RTT variance if availableAmGet the current RTT variance.101010AoNOMAD Protocol - Server LibraryAcServer information.010101AoConvert to a u64 (zero-padded).000BfUpdate RTT estimate with a new sample.000BeMessage was ack-only, no state changeBbAck-only message (no state change)101010BdRequest checkpoint at specific state000AcSession is closing.AnConnection closing gracefully.101010AoMaximum retransmission timeout.0000000AoMinimum retransmission timeout.0000000BiError encoding or decoding sync messages.000AaSend a frame now.000AdOperation timed out.000AbUser ID is present000AoState was updated with the diff000AlGet the byte representation.BnConvert frame type to its byte representation.AgGet the raw byte value.210210210CfApply exponential backoff to RTO (used after timeout).000BnBase checkpoint ID for incremental (0 if full)000AmClean up old address entries.000AjConnect to a NOMAD server.CaConnect to a remote address (for client sockets).101010AhOur current peer version000BlDecrypt ciphertext using XChaCha20-Poly1305.000CgDefault priority for messages without explicit priority000BkEncrypt plaintext using XChaCha20-Poly1305.000BgCreate minimal config (timestamps only)BgCreate config with only normal priority101010B`Record bytes sent to an address.CfRecord that we\xe2\x80\x99re sending a frame with the given \xe2\x80\xa6101010BfCheckpoint payload (may be compressed)000B`Apply speculative input locally.000BfPrelude module for convenient imports.000BbProcess an already-decoded message0000000BaSend state to a specific session.B`Send data to a specific address.101010AnTime when the message was sent000BgUpdate the base RTO from RTT estimator.000BmGet the current smoothed RTT in milliseconds.000AkConvert to wire format byte000AnGet the tracker for inspection000AjAdd an update to the batch000AgUser/session identifier000BaVersion that needs acknowledgmentAoThe version that was duplicated101010ClSize of AAD for data frames (type + flags + session_id + \xe2\x80\xa6000CbFrame contains only acknowledgment, no state diff.000BnBatch multiple small updates into single frame000AgClear all subscriptions0000000ClMust be delivered immediately, may preempt other updates \xe2\x80\xa6000CfMetadata attachment (timestamps, causality, user info)000BcMetadata attached to a sync message000AiNew state update received000CaPattern-based subscriptions (e.g., \xe2\x80\x9cusers/*\xe2\x80\x9d)000BaServer sends periodic checkpoints000CbPriority levels for updates (critical vs cosmetic)000BaPriority levels for state updates000BkA dynamic rate hint sent during the session000AdServer is shut down.000BdInput data is shorter than required.CjInput buffer is too short to contain valid extension data.AcFrame is too short.210210210B`User/session IDs can be attached000BgCreate an ack-only message (empty diff)BoCreate an ACK-only frame (keepalive or pure \xe2\x80\xa6101010AfGet the raw key bytes.AbGet the raw bytes.AlGet the session ID as bytes.0210021002100ChCheck if we can send bytes to an unvalidated address \xe2\x80\xa6000CdCompress data if it meets the minimum size threshold000BaGet duration (None if indefinite)000AaExpected version.AmThe base version we expected.AgMinimum bytes required.0AfMinimum expected size.BdExpected payload length from header.432210432210432210AjExtension type identifiersAiExtension type identifier010101BfGenerate a new random client identity.AnGenerate a new random keypair.BaGenerate a new random session ID.AmGenerate a random session ID.321032103210CfClient identity (optional, generated if not provided).AeClient identity used.101010BgCheck if the connection is still alive.000AgCheck if batch is emptynCheck if empty00BeCheck if any subscriptions are active211102111021110BoCheck if this error is fatal to the connection.000C`Check if reserved bits are valid (must be zero).000BdMaximum uncompressed checkpoint size000BcMinimum size to attempt compression000AkIncrement epoch (on rekey).000AkGet the opposite direction.000A`Get all patterns000AjThe stale version received000BgGet the receive key for the given role.000AjBytes needed for encoding.000BdGet the send key for the given role.000BgUpdate the SRTT from the RTT estimator.000B`Gracefully shut down the server.000BfCheck if a priority level is supported000BeSerialize header to bytes (16 bytes).AnSerialize to bytes (10 bytes).101010AoCreate with custom RTO settings000BbCausality tracking (vector clocks)AiCausality info is present101010AfConnected and syncing.000ChA complete data frame ready for encryption/transmission.000BhFailed to apply the diff to local state.000CbDirection of communication for nonce construction.000BmDuplicate message (already have this version)BmDuplicate message (already seen this version)101010BhExtension TLV (Type-Length-Value) format000BjFrame type identifiers from 0-PROTOCOL.md.000AiBLAKE2s hash output size.000AbInitiator (client)000AmKeepalive to prevent timeout.000AdMaximum epoch value.000AbResponder (server)000CeSession ID - 48-bit random identifier for session \xe2\x80\xa6AmSession identifier (6 bytes).101010AkSubscribe to a region by IDAnSubscribe to a specific region101010AlState synchronization error.0AiErrors in the sync layer.AlErrors from the sync engine.21021010CbCore trait for any state that can be synchronized.000AdTimestamp is present000C`Wait until the specified instant before sending.000AjBytes available in buffer.000AeSet the bind address.AcAddress to bind to.101010B`Broadcast state to all sessions.000CdCheck if we can perform another rekey (epoch limit).000AeCausality information000BcCreate diff from old_state to self.000BoHighest state version acknowledged (encrypted).000AmConvert from wire format byteAaConvert from byte0AmParse frame type from a byte.AmCreate flags from a raw byte.322103221032210lType of hint000AmGet time since last activity.000BcIncrement counter for a participant000AhConsume and get the data000AkCheck if session is active.000BcCheck if the connection has failed.BjCheck if we\xe2\x80\x99ve exceeded max retransmits.101010C`Check if a nonce is a replay (without updating).000BaCheck if checkpoint has signature000AiGet max delay as Duration000A`Migration state.000AoCheck if we need to send an ack000000000000000CeNegotiate extensions between client and server offersBkNegotiate between client and server configsBcNegotiate between client and server0110210011021001102100110BiGet the plaintext that will be encrypted.00000000BjReconcile with authoritative server state.000DdGet the received data after a successful <code>try_recv_from</code>.000BoReceive data and return the sender\xe2\x80\x99s address.000BfRegion ID (only for Region type hints)000AeSet compression level000AfSet the session state.000AbOptional signature000BlGet a mutable reference to the current state000BgState number this checkpoint represents000BcBitmap of supported priority levels000BdTimestamp (microseconds since epoch)CbSender\xe2\x80\x99s current time in ms since session start.101010CfCurrent timestamp in milliseconds since session start.B`NOMAD Protocol - Transport Layer000oTotal wire sizeAhWire size of this configiWire size20221AcWire size of config111321313320111321313320111321313320111B`Create config with specific rate000AfAcknowledgment tracker000BkErrors that can occur when applying a diff.000CeLowest priority, deliver when convenient Use for: \xe2\x80\xa6000AjFailed to bind to address.000BoFull state checkpoint for recovery/initial sync000B`Compressed checkpoints supportedAePayload is compressed101010BhA complete checkpoint (header + payload)000BgA close frame for graceful termination.000AcData was compressed000AlCompressor for sync payloads000AfHandshake in progress.000BbFailed to decode the diff payload.000BkErrors that can occur during frame parsing.000AlFrame flags for data frames.000CbFrame pacer that controls when frames can be sent.000AgTop-level NOMAD errors.000BlTracks pending acknowledgments for a message000BlServer hints for acceptable update frequency000BbBasic region subscribe/unsubscribe000CgA rekey frame for forward secrecy through key rotation.CiTracks the current key epoch and when rekeying is needed.000BcRetransmitting unacknowledged data.000BgAlpha for SRTT smoothing (0.125 = 1/8).000BbReason why a frame should be sent.000BbServer information for connection.000BbA session key for AEAD operations.000CcSync engine for bidirectional state synchronization000C`Sender state for managing outbound sync messages000AjTimestamps can be attached000B`Apply diff to produce new state.000AgCancel all pending acks000AjCreate an ack-only message000oDecompress data000BfGracefully disconnect from the server.AnDisconnect a specific session.101010AkNOMAD Protocol - ExtensionsAeRequested extensions.AfNegotiated extensions.AjGet negotiated extensions.210321032103BeFrame type (should be Data or Close).000BdCreate a new session key from bytes.BlCreate a keypair from existing key material.AfCreate from raw bytes.AoCreate a session ID from bytes.AhParse header from bytes.AaParse from bytes.543210543210543210BmGet the local address the server is bound to.AfGet the local address.101010CcMark that we\xe2\x80\x99ve sent an ack for the given versionAmMark that we\xe2\x80\x99ve sent an ack101010BfRecord bytes received from an address.BhProcess a received frame\xe2\x80\x99s timestamps.101010AcGet the public key.AmServer\xe2\x80\x99s static public key.1101101101BnGet the receive counter for the current epoch.000AmGet all subscribed region IDs000BjMark as retransmitted with updated timeoutAgRetransmission control.101010BkGet the send counter for the current epoch.000CbOutbound nonce counter (monotonically increasing).000AnSession ID assigned by server.AcGet the session ID.0kSession ID.00BbSession identifier from handshake.AcSession identifier.433222104332221043322210oSet custom data000oSet signed flag000BfGet a clone of the Arc-wrapped socket.000BgTimestamp tracking for RTT measurement.000BcGet bitmask for this priority level000CfCreate a timestamp tracker with a specific start time.000AlCompression extension (zstd)000BjErrors that can occur in the NOMAD client.000AfInternal client state.000AkErrors in the crypto layer.000BkErrors that can occur when decoding a diff.000BmConnection established, data transfer active.000AfHandshake in progress.0000000CcIncremental checkpoints (delta from base) supportedBkCheckpoint is incremental (delta from base)101010AoInitial retransmission timeout.CgInitial retransmission timeout before first RTT sample.101010BjCompressed data is malformed or corrupted.BgExtension data is malformed or invalid.101010AcInvalid frame type.000BfOnly normal priority (minimal support)000AhA NOMAD protocol client.000AhA NOMAD protocol server.000BcAsync UDP socket wrapper for NOMAD.000CmNonce replay detected. Per spec: silently drop to prevent \xe2\x80\xa6000CiNonce too old (outside anti-replay window). Per spec: \xe2\x80\xa6000BdAnti-replay window using a bitfield.000AlAction the pacer recommends.000CfOptional trait for states that support client-side \xe2\x80\xa6000BgBeta for RTTVAR smoothing (0.25 = 1/4).000BjErrors that can occur in the NOMAD server.000AfEvent from the server.000BnSession keys derived from the Noise handshake.000BoState has changed and needs to be synchronized.000BoHandle for sending state updates to the server.000BnSync message format (inside encrypted payload)000CaSync tracker state (each endpoint maintains this)000AoUnsubscribe from a region by IDBbUnsubscribe from a specific region101010BeA vector clock for causality tracking000AdWindow size in bits.000oGet bytes saved000AgGet the client address.000AnEnable or disable compression.BgCreate compression extension with level1101101101BfGet current RTO based on RTT estimates000BbDeserialize diff from wire format.000BeSerialize diff for wire transmission.000CbEncode into existing buffer, returns bytes writtenBiEncode into buffer, returns bytes written101010CbCreate a NOMAD socket from an existing UDP socket.BlCreate a socket from an existing UDP socket.101010BoCreate a connection state in handshaking phase.000BjCheck if there are pending acknowledgmentsBdCheck if there\xe2\x80\x99s a pending message101010BgCreate an incremental checkpoint header000BdCheck if this is an ack-only messageAnCheck if ACK_ONLY flag is set.101010BfGet a copy of the current local state.000CmCreate config optimized for low latency (smaller batches, \xe2\x80\xa6000AeMark as fully closed.000oMark as failed.000B`Maximum concurrent subscriptions000BgParse a nonce back into its components.000AlActual payload size in frame000AdGet the private key.0AoSet the server\xe2\x80\x99s private key.BiServer\xe2\x80\x99s static private key (32 bytes).221022102210BbProcess an incoming acknowledgment000BfProcess a raw message from wire format000BbRecord a received message counter.000AmRecord that we sent a message000B`Size constants for rekey frames.AgGet the server address.AgSet the server address.AmServer address to connect to.210210210kSet user ID000AkCheck if we should send now000BeGet target rate as updates per second0000000BgTotal payload bytes (excluding headers)000BfCreate a compressor with custom config000AeClient configuration.000AgClient is disconnected.nNot connected.101010AmExtension set for negotiation000BbInvalid flags (reserved bits set).000BfSync message encoding/decoding errors.000CeRequested extension type is not supported by this \xe2\x80\xa6000AaType of rate hint000AkAnti-replay sliding window.000BdRTT estimator implementing RFC 6298.000AeServer configuration.000nSession error.000nSession state.000ChDecompressed size exceeds safety limit (DoS protection).000AnClient state has been updated.000BcReceiver for incoming sync messages000CiData was not compressed (too small or compression not \xe2\x80\xa6000AiBase version for the diff000ChBump local state version (call when local state changes)000AmGet the current client state.000AlGenerate an ack-only message000BdCheck if a version has been received000B`Consume batch and return updates000BaCheck if the client is connected.000BaCheck if an address is validated.000CcCheck if keys are expired (session must terminate).CkCheck if the current keys are expired (hard limit reached).101010BeMark that the local state has changed000BiMaximum time to hold updates for batching000BnSet the maximum number of concurrent sessions.BfMaximum number of concurrent sessions.101010AdGet peer\xe2\x80\x99s versionBfGet highest version received from peer101010CaProcess the handshake response (&lt;- e, ee, se).D`Process the initiator\xe2\x80\x99s handshake message (-&gt; e, es, s, \xe2\x80\xa6101010AmGet the current server state.000CfCheck if old keys should be cleared due to expired \xe2\x80\xa6000BdCheck if we should initiate a rekey.CiCheck if we should initiate a rekey (soft limit reached).101010BfGet a sender handle for state updates.000BeThe sync message (will be encrypted).000CeForce-take the pending message (bypass timing checks)000AcEncode to extension00000000000000000000000AgUpdate the local state.BnUpdate local state and bump version atomically101010BaPoly1305 authentication tag size.BhAEAD authentication tag size (Poly1305).101010CcA complete crypto session for secure communication.000ChConsider connection dead after this long without frames.CiDead interval - consider connection dead if no frames \xe2\x80\xa6101010CeServer may send dynamic rate hints during the session000CbFrame contains only acknowledgment, no state diff.000CkFrame too small to be valid. Per spec: silently drop to \xe2\x80\xa6000AoExtension data follows payload.000BnHandshake initiation (Noise_IK first message).000BmHandshake response (Noise_IK second message).000AdInvalid diff format.BgMessage format is invalid or corrupted.101010BjPayload header (inside encrypted portion).000BmResult of processing an incoming sync message000BbResult of receiving a sync message000CcUnique type identifier (e.g., \xe2\x80\x9cnomad.echo.v1\xe2\x80\x9d).000AcPer-client session.000CfHandle for sending state updates to a specific client.000CcHandle for receiving state updates from the server.000BoA static X25519 keypair for long-term identity.000AgUnexpected end of data.000AnVersion acknowledged by sender0000000AjAdvance to the next epoch.000AlUnique checkpoint identifier000C`Clear pending state (e.g., after receiving ACK).CfClear the pending timestamp (e.g., on retransmission).101010BdCompress data in-place into a buffer000ClConstruct AAD (Additional Authenticated Data) for a data \xe2\x80\xa6000AiDecrypt a received frame.000BcSuggested duration (0 = indefinite)000AlEncrypt a frame for sending.000AkGet timestamp as SystemTime000BcCheck if HAS_EXTENSION flag is set.000B`Get highest acknowledged version000BhKey for initiator \xe2\x86\x92 responder messages000C`Suggested interval between checkpoints (seconds)000BaCheck if checkpoint is compressedAlCheck if data was compressed101010CcCheck if diff is empty (optimization for ack-only).0000000BbCheck if a region ID is subscribed000BmWhen we last received an authenticated frame.000ChNonce counter (per-direction, monotonically increasing).000CmNotify the pacer that we received a frame and should send \xe2\x80\xa6000BgNotify the pacer that a frame was sent.000BcRecord that we\xe2\x80\x99re retransmitting.000CkParse a decrypted payload to extract the payload header \xe2\x80\xa6000BeGet number of pending acknowledgments000AkQueue a message for sending000CaRegister a sent message that needs acknowledgment000CfReset RTO to initial value (e.g., after successful \xe2\x80\xa6000BhKey for responder \xe2\x86\x92 initiator messages000BbGet the number of active sessions.000mSet causality000AmSet timestamp from SystemTime000CdNumber of payloads skipped (too small or no benefit)000AlState type ID for handshake.000BnTake the pending message if we should send now000BeTry to receive data without blocking.000AbSet ACK_ONLY flag.000AoCreate batch with capacity hint000CjGenerate the first handshake message (-&gt; e, es, s, ss).CbGenerate the handshake response (&lt;- e, ee, se).101010B`Batching extension configuration000AhErrors during bootstrap.000C`Output buffer is too small to hold encoded data.CeOutput buffer is too small to hold encoded extension.101010BhClient can request checkpoints on demand000BhClient identity containing the key pair.000AmResult of compression attempt000BoExtension type: Prediction (terminal-specific).000BoExtension type: Scrollback (terminal-specific).000AhMaximum frame rate (Hz).000BnMinimum frame size (header + tag, no payload).000AfMetadata configuration000AhMigration state tracker.000CeOperation requires initialized state but none exists.000B`Priority extension configuration000A`Replay detected.000CaSelective sync - sync only specific state regions000AkSubscription operation type000B`Timestamp size in rekey payload.AgTransport layer errors.000CjUnknown session ID. Per spec: silently drop to prevent \xe2\x80\xa6000BcVersion this diff was computed from000AfCancel pending message000CkCheck if a nonce is valid (not replayed) and mark it as \xe2\x80\xa6000BmCreate a sync message with current state info000BkParse a rekey frame from decrypted payload.AeDecode from extension00000000000000000000000BlThe handshake hash (used for key derivation)BhThe handshake hash (stored for rekeying)101010BjCheck if this clock happens-before another000AkIncrement the send counter.000BbCheck if checkpoint is incremental000BbCheck if the engine is initializedCmCheck if the estimator has been initialized with at least \xe2\x80\xa6101010ChCheck if this error should result in silent drop (no \xe2\x80\xa6000CeIterate over supported priorities (highest to lowest)000BcMaximum number of updates per batch000CaCalculate maximum frame size considering headers.000nNOMAD ProtocolBgThe payload header (will be encrypted).BhLength of the sync message that follows.CiRekey authentication key for PCS (derived from static DH)AfThe sender\xe2\x80\x99s version0BkGet a sender handle for a specific session.BkSet compressed flag and actual payload sizeAjSet negotiated extensions.BgCheck if we should send at a given timeCgGet the timestamp echo value (peer\xe2\x80\x99s last timestamp).CeMost recent timestamp received from peer (0 if none).AgSet HAS_EXTENSION flag.BeCreate a sender with custom intervalsAmCreate with current timestampAeXChaCha20 nonce size.AhBootstrap configuration.BaResult of a successful bootstrap.AkA new client has connected.AkConnection lifecycle state.CeFull connection state as specified in 2-TRANSPORT.md.CmDefault maximum retransmission timeout (60 seconds). Caps \xe2\x80\xa6ClDefault minimum retransmission timeout (100ms). Prevents \xe2\x80\xa6CeData frame header (unencrypted portion, used as AAD).BcExtension type: Compression (zstd).BiEpoch exhausted - session must terminate.BdData frame (encrypted sync message).AaHandshake failed.0AoResult of a completed handshakeBgRequest incremental from specified baseAaInvalid encoding.CaMaximum retransmission attempts before giving up.BeMaximum retransmits before giving up.CiManages old keys during the transition period after a \xe2\x80\xa6CgReceiver with history for out-of-order message handlingAgX25519 public key size.BhRate hints configuration for negotiationAiSession ID size (48-bit).0BgSession ID (48-bit, as per NOMAD spec).AjState corruption detected.BeResult type for transport operations.AfDiff version mismatch.CdDiff was based on a different version than expected.CcHighest version received from peer (acknowledgment)AiAdd compression extensionAgInitial burst allowanceoBurst allowanceAkSet the connection timeout.AcConnection timeout.BmConstruct a 24-byte XChaCha20-Poly1305 nonce.BbGet the current validated address.AiGet current local versionAoGet current local state versionBoGet versions that have exceeded max retransmitsBdParse server public key from base64.AoCheck if compression is enabledCgCreate config optimized for high throughput (larger \xe2\x80\xa6AoCheck if synchronized with peerBgCheck if the state is in sync with peerCgMark that an ack is needed (triggers delayed ack timer)BeCheck if a region matches any patternBeMaximum total payload bytes per batchAlMaximum custom metadata sizeBdCheck if we should send a keepalive.CiGet the next nonce for sending and increment the counter.BnNotify the pacer that local state has changed.B`Get reference to pending messageB`Process an incoming sync messageoRate hint flagsCbRemote peer address (may change during migration).AhSet the session timeout.AlSession timeout for cleanup.BeCheck if custom metadata is supportedBeCheck if nested regions are supportedClInitial target rate (updates per second * 10, so 1.5/s = \xe2\x80\xa6BeTarget rate (updates per second * 10)B`Get time until next allowed sendAhCheckpoint configurationAiA checkpoint frame headerBcErrors from compression operations.BeStatistics for compression operationsAeConnection is closed.AlFailed to connect to server.CbAEAD decryption failed (invalid tag or corrupted).AgAEAD encryption failed.BcClose frame (graceful termination).lRekey frame.AbInvalid handshake.AcInvalid key format.AjInvalid server public key.BbErrors from extension negotiation.BeServer may send per-region rate hintsAhX25519 private key size.AhProtocol version (v1.0).AoInitiate rekey after this time.C`Size of the session key (32 bytes for XChaCha20)AiSubscribe using a patternBoSubscribe using a pattern (e.g., \xe2\x80\x9cusers/*\xe2\x80\x9d)CiTimestamp tracker for RTT measurement via timestamp echo.CcCheck if a nonce is a replay and update the window.CbCheck if a received nonce is valid (not replayed).BhClear old keys if retention has expired.AmNumber of payloads compressedBnDecrypt ciphertext in-place, removing the tag.BnEncrypt plaintext in-place, appending the tag.BmNew ephemeral public key for the DH exchange.BmCreate identity from an existing private key.BgGenerate a sync message to send to peerBgCheck if there\xe2\x80\x99s unacknowledged data.BfGet highest version received from peer0AmGet the maximum payload size.AmSet the maximum payload size.BaCheck if retransmission is neededBiGet pending acks that need retransmissionCgFrame pacing constants from the protocol specification.B`Process an incoming sync messageAlSet the receive buffer size.AiNumber of retransmissionsBaGet the current retransmit count.BcVersion of sender\xe2\x80\x99s current stateBgGet mutable access to the server state.BdCheck if dynamic hints are supportedBhCheck if region operations are supportedCaTake the pending message if ready at a given timeCeRTT timing constants from the protocol specification.AmTotal bytes after compressionCnValidate an address after receiving an authenticated frame \xe2\x80\xa6AhRequest for a checkpointAiCompression configurationAhZstd compression failed.AiConnection has timed out.CaNonce counter exhausted - session must terminate.CjCounter exhaustion - nonce counter overflow. This is a \xe2\x80\xa6AmHandshake backoff multiplier.AlHandshake timeout (initial).CeHard cap on frame rate (50 Hz = 20ms between frames).BdMinimum size to attempt compression.BkMinimum payload size to attempt compressionBlKeep old keys for late packets during rekey.BlHard limit, reject old keys after this time.AcSession terminated.BhTracks active subscriptions for a clientAnGet the client\xe2\x80\x99s public key.AfClient\xe2\x80\x99s public key.ChGet compression level if this is a compression extensionB`Get compression level if enabledClCompute the static DH shared secret with a remote public \xe2\x80\xa6CjDerive new session keys after a rekey with PCS protection.CjGet the base state number that should be used for diff \xe2\x80\xa6C`Check if this error is a security-related error.AeGet last sent versionCkGet the old initiator key if still within retention window.CkGet the old responder key if still within retention window.AiPerform client bootstrap.AkInbound anti-replay window.AnSet the server\xe2\x80\x99s public key.BhServer\xe2\x80\x99s static public key (32 bytes).BbCheck if we should retransmit now.BlCheck if pattern subscriptions are supportedBjCheck if server sends periodic checkpointsAoCheck if user IDs are supportedAiUncompressed payload sizeBaAnti-amplification limit reached.AjA client has disconnected.BcEphemeral public key size (X25519).AoExtension data follows payload.CcHandshake state machine for the initiator (client).BeSend keepalive if idle for this long.CdKeepalive interval - send keepalive if no data sent.AoNonce counter size (64-bit LE).C`Builder for creating a <code>NomadClient</code>.C`Builder for creating a <code>NomadServer</code>.CgBuilder for creating NOMAD sockets with custom options.CaTotal rekey payload size (ephemeral + timestamp).BcMinimum replay window size in bits.AnRetransmit backoff multiplier.CcHandshake state machine for the responder (server).AmA subscription change requestAdUnsupported version.AoSet the client\xe2\x80\x99s private key.CmClient\xe2\x80\x99s static private key (optional, generated if not \xe2\x80\xa6CaComplete handshake and transition to established.ChDecode from wire format, returning message and bytes \xe2\x80\xa6CiDecode from bytes, returning extension and bytes consumedAmEnable compression extension.0CnCheck if two clocks are concurrent (neither happens-before \xe2\x80\xa6CbCheck if the connection should be considered dead.BhGet last version we acknowledged to peerBaGet highest version acked by peerAoMark a version as retransmittedBnMaximum pattern length (if patterns supported)ClParse a received frame to determine its type and extract \xe2\x80\xa6BhCheck if causality tracking is supportedC`Get time until next allowed send at a given timeAnTotal bytes before compressionBkUpdate the client address (for IP roaming).CeCollection interval for batching rapid state changes.CgWait after state change before sending (batch rapid \xe2\x80\xa6CbDefault initial retransmission timeout (1 second).CeRecommended maximum payload size for mobile networks.BaMaximum delay for ack-only frame.BhMaximum time to delay an ack-only frame.AjZstd decompression failed.AfKey derivation failed.AoFailed to generate client keys.CgMinimum data frame size (header + empty payload + tag).BkNonce direction: Initiator -&gt; Responder.BkNonce direction: Responder -&gt; Initiator.C`Payload header size (timestamp + echo + length).AlSelective sync configurationChHighest state version the peer has acknowledged from us.B`Check if compression is enabled.B`Check if we have updates to sendBhCheck if we have pending updates to sendBcHighest state version we\xe2\x80\x99ve sent.BmCheck if compressed checkpoints are supportedBgCheck if per-region hints are supportedBaCheck if timestamps are supportedBnUpdate the server state and increment version.CmInvalid AEAD tag - frame authentication failed. Per spec: \xe2\x80\xa6CbDefault maximum delay before flushing batch (50ms)AnInitiator \xe2\x86\x92 Responder (0x00)AgMigration rate limited.BdSoft limit on messages before rekey.AnResponder \xe2\x86\x92 Initiator (0x01)AjRetransmission controller.AmGet the client state version.CeHighest state version we\xe2\x80\x99ve acknowledged from peer.AdSelective sync flagsAmGet the server state version.CfSet the maximum payload size (for MTU considerations).BnCheck if incremental checkpoints are supportedBcCreate a tracker with initial stateAmHeader size for extension TLVAjMaximum handshake retries.CiMinimum frame interval (ms) - will use max(SRTT/2, this).AhPayload length mismatch.BcBitmap of supported priority levelsC`Hard limit on messages - MUST terminate session.BhDecompress data with explicit size limitCjDerive the rekey authentication key from static DH secret.BmMaximum causality entries (vector clock size)BnMaximum decompressed size (for DoS protection)AlMetadata configuration flagsBcTime until retransmission is neededBlGet time until next retransmission is neededBjGet time until next retransmit is allowed.AmHeader for a checkpoint frameCkData frame header size (type + flags + session_id + nonce).0BaDefault maximum updates per batchBlMinimum RTT granularity for RTO calculation.BlToo many retransmissions, connection failed.AfCheckpoint frame flagsCdUpdate state after receiving an authenticated frame.BjDefault maximum batch payload size (16 KB)CkDefault maximum number of retransmission attempts (10). \xe2\x80\xa6AlMinimum handshake init size.B`Minimum handshake response size.BlRecommended max payload for mobile networks.AlCheckpoint negotiation flagsBhMetadata presence flags (in wire format)BgCheck if client can request checkpointsBmCheck if we\xe2\x80\x99re within the retention window.AlDefault receive buffer size.CmMinimum time between frames (lower bound). Actual minimum \xe2\x80\xa6BiSync message header size (3 x u64 + u32).BiHeader size in bytes (3 x u64 + u32 = 28)AoDefault zstd compression level.CnDefault zstd compression level (1-22, higher = smaller but \xe2\x80\xa6BnHandshake initiation (Noise_IK first message).BmHandshake response (Noise_IK second message).ChDefault exponential backoff multiplier for RTO (2x). \xe2\x80\xa6ChDefault collection interval for batching rapid state \xe2\x80\xa6AkDefault delayed ack timeoutBkUpdate the client state version (from ack).")