rd_("jI/O error.00AnI/O error (socket operations).11101110AjContains the success value00AcGet the session ID.00BbNeed to acknowledge received data.00AhContains the error value00CkGet the AAD (Additional Authenticated Data) - the frame \xe2\x80\xa6lGet the AAD.1010A`Add an extension00A`Get session age.00AeGet extension by type00AmCheck if extension is present00AdNumber of extensions00AgCreate new server info.AlCreate a new client builder.CdCreate a new sync engine with the required callbacksAhCreate a new pending ackBnCreate a new ack tracker with default settingsAiCreate a new sync messageAeCreate a new receiverAmCreate a new ordered receiverBiCreate a new sender with default settingsAiCreate a new sync trackerBaCreate a new initiator handshake.BaCreate a new responder handshake.C`Create a new retention manager with no old keys.AkCreate a new replay window.CgCreate a new crypto session after handshake completion.BmCreate a new rekey state starting at epoch 0.BmCreate a new compressor with default settingsAfCreate a new extensionAmCreate an empty extension setAlCreate a new server builder.BcCreate a new session ID from bytes.AeCreate a new session.AjCreate a new nonce window.CiCreate a new connection state for an established session.AoCreate a new data frame header.AlCreate a new payload header.AhCreate a new data frame.AiCreate a new close frame.CfCreate a new migration state with the initial address.AiCreate a new frame pacer.BcCreate a new retransmit controller.CaCreate a new socket builder with default options.BoCreate a new RTT estimator with initial values.AoCreate a new timestamp tracker.AgCreate new server info.AlCreate a new client builder.CdCreate a new sync engine with the required callbacksAhCreate a new pending ackBnCreate a new ack tracker with default settingsAiCreate a new sync messageAeCreate a new receiverAmCreate a new ordered receiverBiCreate a new sender with default settingsAiCreate a new sync trackerBaCreate a new initiator handshake.BaCreate a new responder handshake.C`Create a new retention manager with no old keys.AkCreate a new replay window.CgCreate a new crypto session after handshake completion.BmCreate a new rekey state starting at epoch 0.BmCreate a new compressor with default settingsAfCreate a new extensionAmCreate an empty extension setAlCreate a new server builder.BcCreate a new session ID from bytes.AeCreate a new session.AjCreate a new nonce window.CiCreate a new connection state for an established session.AoCreate a new data frame header.AlCreate a new payload header.AhCreate a new data frame.AiCreate a new close frame.CfCreate a new migration state with the initial address.AiCreate a new frame pacer.BcCreate a new retransmit controller.CaCreate a new socket builder with default options.BoCreate a new RTT estimator with initial values.AoCreate a new timestamp tracker.AgCreate new server info.AlCreate a new client builder.CdCreate a new sync engine with the required callbacksAhCreate a new pending ackBnCreate a new ack tracker with default settingsAiCreate a new sync messageAeCreate a new receiverAmCreate a new ordered receiverBiCreate a new sender with default settingsAiCreate a new sync trackerBaCreate a new initiator handshake.BaCreate a new responder handshake.C`Create a new retention manager with no old keys.AkCreate a new replay window.CgCreate a new crypto session after handshake completion.BmCreate a new rekey state starting at epoch 0.BmCreate a new compressor with default settingsAfCreate a new extensionAmCreate an empty extension setAlCreate a new server builder.BcCreate a new session ID from bytes.AeCreate a new session.AjCreate a new nonce window.CiCreate a new connection state for an established session.AoCreate a new data frame header.AlCreate a new payload header.AhCreate a new data frame.AiCreate a new close frame.CfCreate a new migration state with the initial address.AiCreate a new frame pacer.BcCreate a new retransmit controller.CaCreate a new socket builder with default options.BoCreate a new RTT estimator with initial values.AoCreate a new timestamp tracker.CcGet the current timestamp (ms since session start).00AnCurrent retransmission timeoutBgGet the current retransmission timeout.1010oRTT estimation.00AeEncrypted data frame.00CfDiff representation (must be idempotent when applied).00BcNo action needed (nothing to send).00mNo flags set.00ChRole in the handshake (affects which key is used for \xe2\x80\xa600kSync error.00oServer address.00BhBind to an address and start the server.CeCreate a new NOMAD socket bound to the given address.BnBind to the given address and create a socket.210210CcNOMAD Protocol - Core traits, types, and constants.00AbGet the data bytesnExtension data1010BbApplication-specific diff encoding00AoReturns the argument unchanged.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000BhInitialize the engine with initial state00BaCalls <code>U::from(self)</code>.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000AbGet all extensions00CeDetermine what action to take based on current state.00BnReceive the next state update from the server.BhReceive data from the connected address.1010AeGet the current role.00BbSend a state update to the server.BoSend a state update to this session\xe2\x80\x99s client.BcSend data to the connected address.210210AiActual decompressed size.0BaGet the smoothed RTT if availableAmGet the current smoothed RTT.1010AkNOMAD Protocol - Sync Layer00BgCreate a zero session ID (for testing).00lApply error.00AjGraceful connection close.00AdFrame parsing error.00BcUser input type (e.g., keystrokes).00CdK multiplier for RTO calculation (4.0 per RFC 6298).00AgRekey request/response.00CaOld message (version lower than already received)00AoBuild the client configuration.AoBuild the server configuration.1010CjClear old keys (call after retention window expires or \xe2\x80\xa6AdClear all extensions1010AkTransition to closed state.AlCreate a close frame header.1010BcCreate an empty extension (no data)00AfGet the current epoch.0BdCurrent epoch (increments on rekey).110110lFrame flags.00BiGet a reference to the underlying socket.00AeGet compression levelAhCompression level (1-22)1010AeMaximum allowed size.0mFrame pacing.00AiCurrent connection phase.00CaGet compression ratio (compressed / uncompressed)00AjPerform a rekey operation.00A`Reset the engineAcReset tracker stateAdReset receiver state0AbReset sender stateBbReset the tracker to initial stateBeReset the window (e.g., after rekey).54332105433210BoSize constants from the protocol specification.00BdGet a reference to the current stateAfGet the session state.AnThe new state from the client.210210A`Record activity.00AnSession is active and syncing.00AmConnection closed gracefully.AbSession is closed.AbConnection closed.210210AdConfiguration error.00mCrypto error.00mDecode error.00CgConnection failed (timeout, too many retransmits, etc).00oActual version.AeActual size received.AgActual bytes available.2AjThe base version received.AfActual bytes received.232410232C`Cancel a pending ack (e.g., on connection close)00AoNOMAD Protocol - Client Library00AmGet the server configuration.00AoNOMAD Protocol - Security Layer00AgDecode from wire formatAaDecode from bytesBaDecode all extensions from buffer210210BnDerive session keys from the handshake result.00BmEncode to wire format (28-byte header + diff)oEncode to bytesAeEncode all extensions210210BeThe unencrypted header (used as AAD).AaThe frame header.1010AoUpdate the acked state version.BfReset after successful acknowledgment.1010AkRecord a compression result00AkRemove an extension by type00BdRetain the current keys as old keys.00BaGet the RTT variance if availableAmGet the current RTT variance.1010AoNOMAD Protocol - Server LibraryAcServer information.0101AoConvert to a u64 (zero-padded).00BfUpdate RTT estimate with a new sample.00BeMessage was ack-only, no state changeBbAck-only message (no state change)1010AcSession is closing.AnConnection closing gracefully.1010AoMaximum retransmission timeout.00000AoMinimum retransmission timeout.00000BiError encoding or decoding sync messages.0AaSend a frame now.00AdOperation timed out.00AoState was updated with the diff00AlGet the byte representation.BnConvert frame type to its byte representation.AgGet the raw byte value.210210CfApply exponential backoff to RTO (used after timeout).00AmClean up old address entries.00AjConnect to a NOMAD server.CaConnect to a remote address (for client sockets).1010AhOur current peer version00BlDecrypt ciphertext using XChaCha20-Poly1305.00BkEncrypt plaintext using XChaCha20-Poly1305.00B`Record bytes sent to an address.CfRecord that we\xe2\x80\x99re sending a frame with the given \xe2\x80\xa61010B`Apply speculative input locally.00BfPrelude module for convenient imports.00BbProcess an already-decoded message00000BaSend state to a specific session.B`Send data to a specific address.1010AnTime when the message was sent00BgUpdate the base RTO from RTT estimator.00BmGet the current smoothed RTT in milliseconds.00AnGet the tracker for inspection00BaVersion that needs acknowledgmentAoThe version that was duplicated1010ClSize of AAD for data frames (type + flags + session_id + \xe2\x80\xa600CbFrame contains only acknowledgment, no state diff.00AiNew state update received00AdServer is shut down.00AcFrame is too short.BdInput data is shorter than required.CjInput buffer is too short to contain valid extension data.2102BgCreate an ack-only message (empty diff)BoCreate an ACK-only frame (keepalive or pure \xe2\x80\xa61010AfGet the raw key bytes.AbGet the raw bytes.AlGet the session ID as bytes.021002100ChCheck if we can send bytes to an unvalidated address \xe2\x80\xa600CdCompress data if it meets the minimum size threshold00AaExpected version.AfMinimum expected size.BdExpected payload length from header.2AmThe base version we expected.AgMinimum bytes required.032410032AjExtension type identifiersAiExtension type identifier0101BfGenerate a new random client identity.AnGenerate a new random keypair.BaGenerate a new random session ID.AmGenerate a random session ID.32103210CfClient identity (optional, generated if not provided).AeClient identity used.1010BgCheck if the connection is still alive.00nCheck if empty00BoCheck if this error is fatal to the connection.00C`Check if reserved bits are valid (must be zero).00BcMinimum size to attempt compression00AkIncrement epoch (on rekey).00AkGet the opposite direction.00AjThe stale version received00BgGet the receive key for the given role.00AjBytes needed for encoding.0BdGet the send key for the given role.00BgUpdate the SRTT from the RTT estimator.00B`Gracefully shut down the server.00BeSerialize header to bytes (16 bytes).AnSerialize to bytes (10 bytes).1010AoCreate with custom RTO settings00AfConnected and syncing.00ChA complete data frame ready for encryption/transmission.00BhFailed to apply the diff to local state.0CbDirection of communication for nonce construction.00BmDuplicate message (already have this version)BmDuplicate message (already seen this version)1010BhExtension TLV (Type-Length-Value) format00BjFrame type identifiers from 0-PROTOCOL.md.00AiBLAKE2s hash output size.00AbInitiator (client)00AmKeepalive to prevent timeout.00AdMaximum epoch value.00AbResponder (server)00CeSession ID - 48-bit random identifier for session \xe2\x80\xa6AmSession identifier (6 bytes).1010AlState synchronization error.0AiErrors in the sync layer.AlErrors from the sync engine.2101AkErrors from the sync engineCbCore trait for any state that can be synchronized.00C`Wait until the specified instant before sending.00AjBytes available in buffer.0AeSet the bind address.AcAddress to bind to.1010B`Broadcast state to all sessions.00CdCheck if we can perform another rekey (epoch limit).00BcCreate diff from old_state to self.00BoHighest state version acknowledged (encrypted).00AmParse frame type from a byte.AmCreate flags from a raw byte.1010AmGet time since last activity.00AhConsume and get the data00AkCheck if session is active.00BcCheck if the connection has failed.BjCheck if we\xe2\x80\x99ve exceeded max retransmits.1010C`Check if a nonce is a replay (without updating).00A`Migration state.00AoCheck if we need to send an ack00000000000CeNegotiate extensions between client and server offers00BiGet the plaintext that will be encrypted.00000BjReconcile with authoritative server state.00DdGet the received data after a successful <code>try_recv_from</code>.00BoReceive data and return the sender\xe2\x80\x99s address.00AeSet compression level00AfSet the session state.00BlGet a mutable reference to the current state00CbSender\xe2\x80\x99s current time in ms since session start.00B`NOMAD Protocol - Transport Layer00oTotal wire size00000000AfAcknowledgment tracker00BkErrors that can occur when applying a diff.00AjFailed to bind to address.00BgA close frame for graceful termination.00AcData was compressed00AlCompressor for sync payloads00AfHandshake in progress.00BbFailed to decode the diff payload.0BkErrors that can occur during frame parsing.00AlFrame flags for data frames.00CbFrame pacer that controls when frames can be sent.00AgTop-level NOMAD errors.00BhPrediction extension (terminal-specific)00BlTracks pending acknowledgments for a message00CiTracks the current key epoch and when rekeying is needed.00BcRetransmitting unacknowledged data.00BhScrollback extension (terminal-specific)00BgAlpha for SRTT smoothing (0.125 = 1/8).00BbReason why a frame should be sent.00BbServer information for connection.00BbA session key for AEAD operations.00CcSync engine for bidirectional state synchronization00C`Sender state for managing outbound sync messages00B`Apply diff to produce new state.00AgCancel all pending acks00AjCreate an ack-only message00oDecompress data00BfGracefully disconnect from the server.AnDisconnect a specific session.1010AkNOMAD Protocol - ExtensionsAeRequested extensions.AfNegotiated extensions.AjGet negotiated extensions.21032103BeFrame type (should be Data or Close).00BdCreate a new session key from bytes.BlCreate a keypair from existing key material.AfCreate from raw bytes.AoCreate a session ID from bytes.AhParse header from bytes.AaParse from bytes.543210543210BmGet the local address the server is bound to.AfGet the local address.1010CcMark that we\xe2\x80\x99ve sent an ack for the given versionAmMark that we\xe2\x80\x99ve sent an ack1010BfRecord bytes received from an address.BhProcess a received frame\xe2\x80\x99s timestamps.1010AcGet the public key.AmServer\xe2\x80\x99s static public key.1101101BnGet the receive counter for the current epoch.00BjMark as retransmitted with updated timeoutAgRetransmission control.1010BkGet the send counter for the current epoch.00CbOutbound nonce counter (monotonically increasing).00AnSession ID assigned by server.AcGet the session ID.0kSession ID.00BbSession identifier from handshake.AcSession identifier.4332221043322210BfGet a clone of the Arc-wrapped socket.00BgTimestamp tracking for RTT measurement.00CfCreate a timestamp tracker with a specific start time.00AlCompression extension (zstd)00BjErrors that can occur in the NOMAD client.00AfInternal client state.00AkErrors in the crypto layer.00BkErrors that can occur when decoding a diff.00BmConnection established, data transfer active.00AfHandshake in progress.00000AoInitial retransmission timeout.CgInitial retransmission timeout before first RTT sample.1010BjCompressed data is malformed or corrupted.BgExtension data is malformed or invalid.10AcInvalid frame type.00AhA NOMAD protocol client.00AhA NOMAD protocol server.00BcAsync UDP socket wrapper for NOMAD.00CmNonce replay detected. Per spec: silently drop to prevent \xe2\x80\xa600CiNonce too old (outside anti-replay window). Per spec: \xe2\x80\xa600BdAnti-replay window using a bitfield.00AlAction the pacer recommends.00CfOptional trait for states that support client-side \xe2\x80\xa600BgBeta for RTTVAR smoothing (0.25 = 1/4).00BjErrors that can occur in the NOMAD server.00AfEvent from the server.00BnSession keys derived from the Noise handshake.00BoState has changed and needs to be synchronized.00BoHandle for sending state updates to the server.00BnSync message format (inside encrypted payload)00CaSync tracker state (each endpoint maintains this)00AdWindow size in bits.00oGet bytes saved00AgGet the client address.00AnEnable or disable compression.BgCreate compression extension with level1101101BfGet current RTO based on RTT estimates00BbDeserialize diff from wire format.00BeSerialize diff for wire transmission.00CbEncode into existing buffer, returns bytes writtenBiEncode into buffer, returns bytes written1010CbCreate a NOMAD socket from an existing UDP socket.BlCreate a socket from an existing UDP socket.1010BoCreate a connection state in handshaking phase.00BjCheck if there are pending acknowledgmentsBdCheck if there\xe2\x80\x99s a pending message1010BdCheck if this is an ack-only messageAnCheck if ACK_ONLY flag is set.1010BfGet a copy of the current local state.00AeMark as fully closed.00oMark as failed.00BgParse a nonce back into its components.00AdGet the private key.0AoSet the server\xe2\x80\x99s private key.BiServer\xe2\x80\x99s static private key (32 bytes).22102210BbProcess an incoming acknowledgment00BfProcess a raw message from wire format00BbRecord a received message counter.00AmRecord that we sent a message00AgGet the server address.AgSet the server address.AmServer address to connect to.210210AkCheck if we should send now00BfCreate a compressor with custom config00AeClient configuration.00AgClient is disconnected.nNot connected.1010AmExtension set for negotiation00BbInvalid flags (reserved bits set).00BfSync message encoding/decoding errors.0BeSync message encoding/decoding errorsCeRequested extension type is not supported by this \xe2\x80\xa60AkAnti-replay sliding window.00BdRTT estimator implementing RFC 6298.00AeServer configuration.00nSession error.00nSession state.00ChDecompressed size exceeds safety limit (DoS protection).0AnClient state has been updated.00BcReceiver for incoming sync messages00CiData was not compressed (too small or compression not \xe2\x80\xa600AiBase version for the diff00ChBump local state version (call when local state changes)00AmGet the current client state.00AlGenerate an ack-only message00BdCheck if a version has been received00BaCheck if the client is connected.00BaCheck if an address is validated.00CcCheck if keys are expired (session must terminate).CkCheck if the current keys are expired (hard limit reached).1010BeMark that the local state has changed00BnSet the maximum number of concurrent sessions.BfMaximum number of concurrent sessions.1010AdGet peer\xe2\x80\x99s versionBfGet highest version received from peer1010CaProcess the handshake response (&lt;- e, ee, se).D`Process the initiator\xe2\x80\x99s handshake message (-&gt; e, es, s, \xe2\x80\xa61010AmGet the current server state.00CfCheck if old keys should be cleared due to expired \xe2\x80\xa600BdCheck if we should initiate a rekey.CiCheck if we should initiate a rekey (soft limit reached).1010BfGet a sender handle for state updates.00BeThe sync message (will be encrypted).00CeForce-take the pending message (bypass timing checks)00AgUpdate the local state.BnUpdate local state and bump version atomically1010BaPoly1305 authentication tag size.BhAEAD authentication tag size (Poly1305).1010CcA complete crypto session for secure communication.00ChConsider connection dead after this long without frames.CiDead interval - consider connection dead if no frames \xe2\x80\xa61010CbFrame contains only acknowledgment, no state diff.00CkFrame too small to be valid. Per spec: silently drop to \xe2\x80\xa600AoExtension data follows payload.00BnHandshake initiation (Noise_IK first message).00BmHandshake response (Noise_IK second message).00AdInvalid diff format.0BgMessage format is invalid or corrupted.10BjPayload header (inside encrypted portion).00BmResult of processing an incoming sync message00BbResult of receiving a sync message00CcUnique type identifier (e.g., \xe2\x80\x9cnomad.echo.v1\xe2\x80\x9d).00AcPer-client session.00CfHandle for sending state updates to a specific client.00CcHandle for receiving state updates from the server.00BoA static X25519 keypair for long-term identity.00AgUnexpected end of data.00AnVersion acknowledged by sender00000AjAdvance to the next epoch.00C`Clear pending state (e.g., after receiving ACK).CfClear the pending timestamp (e.g., on retransmission).1010BdCompress data in-place into a buffer00ClConstruct AAD (Additional Authenticated Data) for a data \xe2\x80\xa600AiDecrypt a received frame.00AlEncrypt a frame for sending.00BcCheck if HAS_EXTENSION flag is set.00B`Get highest acknowledged version00BhKey for initiator \xe2\x86\x92 responder messages00AlCheck if data was compressed00CcCheck if diff is empty (optimization for ack-only).00000BmWhen we last received an authenticated frame.00ChNonce counter (per-direction, monotonically increasing).00CmNotify the pacer that we received a frame and should send \xe2\x80\xa600BgNotify the pacer that a frame was sent.00BcRecord that we\xe2\x80\x99re retransmitting.00CkParse a decrypted payload to extract the payload header \xe2\x80\xa600BeGet number of pending acknowledgments00AkQueue a message for sending00CaRegister a sent message that needs acknowledgment00CfReset RTO to initial value (e.g., after successful \xe2\x80\xa600BhKey for responder \xe2\x86\x92 initiator messages00BbGet the number of active sessions.00CdNumber of payloads skipped (too small or no benefit)00AlState type ID for handshake.00BnTake the pending message if we should send now00BeTry to receive data without blocking.00AbSet ACK_ONLY flag.00CjGenerate the first handshake message (-&gt; e, es, s, ss).CbGenerate the handshake response (&lt;- e, ee, se).1010AhErrors during bootstrap.00C`Output buffer is too small to hold encoded data.CeOutput buffer is too small to hold encoded extension.10BhClient identity containing the key pair.00AmResult of compression attempt00BoExtension type: Prediction (terminal-specific).00BoExtension type: Scrollback (terminal-specific).00AhMaximum frame rate (Hz).00BnMinimum frame size (header + tag, no payload).00AhMigration state tracker.00CeOperation requires initialized state but none exists.0A`Replay detected.00AgTransport layer errors.00CjUnknown session ID. Per spec: silently drop to prevent \xe2\x80\xa600BcVersion this diff was computed from00AfCancel pending message00CkCheck if a nonce is valid (not replayed) and mark it as \xe2\x80\xa600BmCreate a sync message with current state info00BlThe handshake hash (used for key derivation)BhThe handshake hash (stored for rekeying)1010AkIncrement the send counter.00BbCheck if the engine is initializedCmCheck if the estimator has been initialized with at least \xe2\x80\xa61010ChCheck if this error should result in silent drop (no \xe2\x80\xa600CaCalculate maximum frame size considering headers.00nNOMAD ProtocolBgThe payload header (will be encrypted).BhLength of the sync message that follows.AfThe sender\xe2\x80\x99s version0BkGet a sender handle for a specific session.AjSet negotiated extensions.BgCheck if we should send at a given timeCgGet the timestamp echo value (peer\xe2\x80\x99s last timestamp).CeMost recent timestamp received from peer (0 if none).AgSet HAS_EXTENSION flag.BeCreate a sender with custom intervalsAeXChaCha20 nonce size.AhBootstrap configuration.BaResult of a successful bootstrap.AkA new client has connected.AkConnection lifecycle state.CeFull connection state as specified in 2-TRANSPORT.md.CmDefault maximum retransmission timeout (60 seconds). Caps \xe2\x80\xa6ClDefault minimum retransmission timeout (100ms). Prevents \xe2\x80\xa6CeData frame header (unencrypted portion, used as AAD).BcExtension type: Compression (zstd).BiEpoch exhausted - session must terminate.BdData frame (encrypted sync message).AaHandshake failed.0AoResult of a completed handshakeAaInvalid encoding.CaMaximum retransmission attempts before giving up.BeMaximum retransmits before giving up.CiManages old keys during the transition period after a \xe2\x80\xa6CgReceiver with history for out-of-order message handlingAgX25519 public key size.AiSession ID size (48-bit).0BgSession ID (48-bit, as per NOMAD spec).AjState corruption detected.BeResult type for transport operations.AfDiff version mismatch.CdDiff was based on a different version than expected.CcHighest version received from peer (acknowledgment)AiAdd compression extensionAkSet the connection timeout.AcConnection timeout.BmConstruct a 24-byte XChaCha20-Poly1305 nonce.BbGet the current validated address.AiGet current local versionAoGet current local state versionBoGet versions that have exceeded max retransmitsBdParse server public key from base64.AoCheck if compression is enabledAoCheck if synchronized with peerBgCheck if the state is in sync with peerCgMark that an ack is needed (triggers delayed ack timer)BdCheck if we should send a keepalive.CiGet the next nonce for sending and increment the counter.BnNotify the pacer that local state has changed.B`Get reference to pending messageB`Process an incoming sync messageCbRemote peer address (may change during migration).AhSet the session timeout.AlSession timeout for cleanup.B`Get time until next allowed sendBcErrors from compression operations.BeStatistics for compression operationsAeConnection is closed.AlFailed to connect to server.CbAEAD decryption failed (invalid tag or corrupted).AgAEAD encryption failed.BcClose frame (graceful termination).lRekey frame.AbInvalid handshake.AcInvalid key format.AjInvalid server public key.BbErrors from extension negotiation.AhX25519 private key size.AhProtocol version (v1.0).AoInitiate rekey after this time.C`Size of the session key (32 bytes for XChaCha20)CiTimestamp tracker for RTT measurement via timestamp echo.CcCheck if a nonce is a replay and update the window.CbCheck if a received nonce is valid (not replayed).BhClear old keys if retention has expired.AmNumber of payloads compressedBnDecrypt ciphertext in-place, removing the tag.BnEncrypt plaintext in-place, appending the tag.BmCreate identity from an existing private key.BgGenerate a sync message to send to peerBgCheck if there\xe2\x80\x99s unacknowledged data.BfGet highest version received from peer0AmGet the maximum payload size.AmSet the maximum payload size.BaCheck if retransmission is neededBiGet pending acks that need retransmissionCgFrame pacing constants from the protocol specification.B`Process an incoming sync messageAlSet the receive buffer size.AiNumber of retransmissionsBaGet the current retransmit count.BcVersion of sender\xe2\x80\x99s current stateBgGet mutable access to the server state.CaTake the pending message if ready at a given timeCeRTT timing constants from the protocol specification.AmTotal bytes after compressionCnValidate an address after receiving an authenticated frame \xe2\x80\xa6AiCompression configurationAhZstd compression failed.AiConnection has timed out.CaNonce counter exhausted - session must terminate.CjCounter exhaustion - nonce counter overflow. This is a \xe2\x80\xa6AmHandshake backoff multiplier.AlHandshake timeout (initial).CeHard cap on frame rate (50 Hz = 20ms between frames).BdMinimum size to attempt compression.BkMinimum payload size to attempt compressionBlKeep old keys for late packets during rekey.BlHard limit, reject old keys after this time.AcSession terminated.AnGet the client\xe2\x80\x99s public key.AfClient\xe2\x80\x99s public key.ChGet compression level if this is a compression extensionB`Get compression level if enabledBfDerive new session keys after a rekey.CjGet the base state number that should be used for diff \xe2\x80\xa6C`Check if this error is a security-related error.AeGet last sent versionCkGet the old initiator key if still within retention window.CkGet the old responder key if still within retention window.AiPerform client bootstrap.AkInbound anti-replay window.AnSet the server\xe2\x80\x99s public key.BhServer\xe2\x80\x99s static public key (32 bytes).BbCheck if we should retransmit now.BaAnti-amplification limit reached.AjA client has disconnected.AoExtension data follows payload.CcHandshake state machine for the initiator (client).BeSend keepalive if idle for this long.CdKeepalive interval - send keepalive if no data sent.AoNonce counter size (64-bit LE).C`Builder for creating a <code>NomadClient</code>.C`Builder for creating a <code>NomadServer</code>.CgBuilder for creating NOMAD sockets with custom options.BcMinimum replay window size in bits.AnRetransmit backoff multiplier.CcHandshake state machine for the responder (server).AdUnsupported version.AoSet the client\xe2\x80\x99s private key.CmClient\xe2\x80\x99s static private key (optional, generated if not \xe2\x80\xa6CaComplete handshake and transition to established.ChDecode from wire format, returning message and bytes \xe2\x80\xa6CiDecode from bytes, returning extension and bytes consumedAmEnable compression extension.0CbCheck if the connection should be considered dead.BhGet last version we acknowledged to peerBaGet highest version acked by peerAoMark a version as retransmittedClParse a received frame to determine its type and extract \xe2\x80\xa6C`Get time until next allowed send at a given timeAnTotal bytes before compressionBkUpdate the client address (for IP roaming).CeCollection interval for batching rapid state changes.CgWait after state change before sending (batch rapid \xe2\x80\xa6CbDefault initial retransmission timeout (1 second).CeRecommended maximum payload size for mobile networks.BaMaximum delay for ack-only frame.BhMaximum time to delay an ack-only frame.AjZstd decompression failed.AfKey derivation failed.AoFailed to generate client keys.CgMinimum data frame size (header + empty payload + tag).BkNonce direction: Initiator -&gt; Responder.BkNonce direction: Responder -&gt; Initiator.C`Payload header size (timestamp + echo + length).ChHighest state version the peer has acknowledged from us.B`Check if compression is enabled.B`Check if we have updates to sendBhCheck if we have pending updates to sendBcHighest state version we\xe2\x80\x99ve sent.BnUpdate the server state and increment version.CmInvalid AEAD tag - frame authentication failed. Per spec: \xe2\x80\xa6AnInitiator \xe2\x86\x92 Responder (0x00)AgMigration rate limited.BdSoft limit on messages before rekey.AnResponder \xe2\x86\x92 Initiator (0x01)AjRetransmission controller.AmGet the client state version.CeHighest state version we\xe2\x80\x99ve acknowledged from peer.AmGet the server state version.CfSet the maximum payload size (for MTU considerations).BcCreate a tracker with initial stateAmHeader size for extension TLVAjMaximum handshake retries.CiMinimum frame interval (ms) - will use max(SRTT/2, this).AhPayload length mismatch.C`Hard limit on messages - MUST terminate session.BhDecompress data with explicit size limitBnMaximum decompressed size (for DoS protection)BcTime until retransmission is neededBlGet time until next retransmission is neededBjGet time until next retransmit is allowed.CkData frame header size (type + flags + session_id + nonce).0BlMinimum RTT granularity for RTO calculation.BlToo many retransmissions, connection failed.CdUpdate state after receiving an authenticated frame.CkDefault maximum number of retransmission attempts (10). \xe2\x80\xa6AlMinimum handshake init size.B`Minimum handshake response size.BlRecommended max payload for mobile networks.BmCheck if we\xe2\x80\x99re within the retention window.AlDefault receive buffer size.CmMinimum time between frames (lower bound). Actual minimum \xe2\x80\xa6BiSync message header size (3 x u64 + u32).BiHeader size in bytes (3 x u64 + u32 = 28)AoDefault zstd compression level.CnDefault zstd compression level (1-22, higher = smaller but \xe2\x80\xa6BnHandshake initiation (Noise_IK first message).BmHandshake response (Noise_IK second message).ChDefault exponential backoff multiplier for RTO (2x). \xe2\x80\xa6ChDefault collection interval for batching rapid state \xe2\x80\xa6AkDefault delayed ack timeoutBkUpdate the client state version (from ack).")